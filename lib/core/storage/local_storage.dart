import 'package:flutter/foundation.dart';
import 'package:hive_flutter/hive_flutter.dart';
import '../constants.dart';
import '../../models/message.dart';
import '../../models/chat_room.dart';
import '../../models/peer.dart';
import '../../models/user_identity.dart';

/// Local storage using Hive for messages, chat rooms, peers, and user data.
class LocalStorage {
  Box<String>? _messagesBox;
  Box<String>? _chatRoomsBox;
  Box<String>? _peersBox;
  Box<String>? _userBox;

  /// Whether all four Hive boxes have been successfully opened.
  bool get isDatabasesOpen =>
      _messagesBox != null &&
      _chatRoomsBox != null &&
      _peersBox != null &&
      _userBox != null;

  /// Initialize Hive (Call once on boot)
  Future<void> init() async {
    await Hive.initFlutter();
    debugPrint('LocalStorage initialized (Databases locked)');
  }

  /// Open databases with AES cipher (Call from AppLockService).
  ///
  /// If existing box files on disk cannot be decrypted (e.g. the
  /// encryption key was regenerated by a previous bug), the corrupted
  /// files are deleted and new empty boxes are created so the app can
  /// continue instead of being permanently bricked.
  Future<void> openDatabases(List<int> encryptionKey) async {
    final cipher = HiveAesCipher(encryptionKey);

    try {
      _messagesBox = await Hive.openBox<String>(
          AppConstants.messagesBox, encryptionCipher: cipher);
      _chatRoomsBox = await Hive.openBox<String>(
          AppConstants.chatRoomsBox, encryptionCipher: cipher);
      _peersBox = await Hive.openBox<String>(
          AppConstants.peersBox, encryptionCipher: cipher);
      _userBox = await Hive.openBox<String>(
          AppConstants.userBox, encryptionCipher: cipher);
    } catch (e) {
      debugPrint('[Storage] Failed to open encrypted boxes: $e');
      debugPrint('[Storage] Deleting corrupted box files and re-creating…');

      // Close any that might have opened before the error
      await _safeCloseAll();

      // Wipe the unreadable files from disk
      await Hive.deleteBoxFromDisk(AppConstants.messagesBox);
      await Hive.deleteBoxFromDisk(AppConstants.chatRoomsBox);
      await Hive.deleteBoxFromDisk(AppConstants.peersBox);
      await Hive.deleteBoxFromDisk(AppConstants.userBox);

      // Re-open as fresh empty boxes with the current key
      _messagesBox = await Hive.openBox<String>(
          AppConstants.messagesBox, encryptionCipher: cipher);
      _chatRoomsBox = await Hive.openBox<String>(
          AppConstants.chatRoomsBox, encryptionCipher: cipher);
      _peersBox = await Hive.openBox<String>(
          AppConstants.peersBox, encryptionCipher: cipher);
      _userBox = await Hive.openBox<String>(
          AppConstants.userBox, encryptionCipher: cipher);
    }

    debugPrint('Hive DBs Opened & Decrypted successfully.');
  }

  /// Close and flush keys from RAM
  Future<void> closeAll() async {
    await _safeCloseAll();
    debugPrint('Hive DBs Locked.');
  }

  Future<void> _safeCloseAll() async {
    if (_messagesBox?.isOpen ?? false) await _messagesBox!.close();
    if (_chatRoomsBox?.isOpen ?? false) await _chatRoomsBox!.close();
    if (_peersBox?.isOpen ?? false) await _peersBox!.close();
    if (_userBox?.isOpen ?? false) await _userBox!.close();
  }

  // ─── User Identity ────────────────────────────────────────────

  Future<void> saveUserIdentity(UserIdentity identity) async {
    await _userBox?.put('identity', identity.encode());
  }

  Future<UserIdentity?> getUserIdentity() async {
    final data = _userBox?.get('identity');
    if (data == null) return null;
    return UserIdentity.decode(data);
  }

  Future<void> setDHTActive(bool isActive) async {
    await _userBox?.put('dhtActive', isActive ? 'true' : 'false');
  }

  Future<bool> isDHTActive() async {
    return _userBox?.get('dhtActive') == 'true';
  }

  // ─── Messages ─────────────────────────────────────────────────

  Future<void> saveMessage(ChatMessage message) async {
    await _messagesBox?.put(message.id, message.encode());
  }

  Future<void> updateMessageStatus(
    String messageId,
    MessageStatus status,
  ) async {
    final data = _messagesBox?.get(messageId);
    if (data != null) {
      final msg = ChatMessage.decode(data);
      final updated = msg.copyWith(status: status);
      await _messagesBox?.put(messageId, updated.encode());
    }
  }

  Future<List<ChatMessage>> getMessagesForRoom(String roomId) async {
    final messages = <ChatMessage>[];
    final box = _messagesBox;
    if (box == null || !box.isOpen) return messages;
    for (final key in box.keys) {
      final data = box.get(key);
      if (data != null) {
        final msg = ChatMessage.decode(data);
        if (msg.roomId == roomId) {
          messages.add(msg);
        }
      }
    }
    messages.sort((a, b) => a.timestamp.compareTo(b.timestamp));
    return messages;
  }

  // ─── Chat Rooms ───────────────────────────────────────────────

  Future<void> saveChatRoom(ChatRoom room) async {
    await _chatRoomsBox?.put(room.id, room.encode());
  }

  Future<List<ChatRoom>> getChatRooms() async {
    final rooms = <ChatRoom>[];
    final box = _chatRoomsBox;
    if (box == null || !box.isOpen) return rooms;
    for (final key in box.keys) {
      final data = box.get(key);
      if (data != null) {
        rooms.add(ChatRoom.decode(data));
      }
    }
    rooms.sort((a, b) {
      final aTime = a.lastMessageAt ?? a.createdAt;
      final bTime = b.lastMessageAt ?? b.createdAt;
      return bTime.compareTo(aTime); // Most recent first
    });
    return rooms;
  }

  Future<ChatRoom?> getChatRoomByPeerId(String peerId) async {
    final box = _chatRoomsBox;
    if (box == null || !box.isOpen) return null;
    for (final key in box.keys) {
      final data = box.get(key);
      if (data != null) {
        final room = ChatRoom.decode(data);
        if (room.peerId == peerId) return room;
      }
    }
    return null;
  }

  // ─── Peers ────────────────────────────────────────────────────

  Future<void> savePeer(Peer peer) async {
    await _peersBox?.put(peer.nyxChatId, peer.encode());
  }

  Future<List<Peer>> getPeers() async {
    final peers = <Peer>[];
    final box = _peersBox;
    if (box == null || !box.isOpen) return peers;
    for (final key in box.keys) {
      final data = box.get(key);
      if (data != null) {
        peers.add(Peer.decode(data));
      }
    }
    return peers;
  }

  Future<Peer?> getPeer(String nyxChatId) async {
    final data = _peersBox?.get(nyxChatId);
    if (data == null) return null;
    return Peer.decode(data);
  }

  // ─── Cleanup ──────────────────────────────────────────────────

  Future<void> clearAll() async {
    if (_messagesBox?.isOpen ?? false) await _messagesBox!.clear();
    if (_chatRoomsBox?.isOpen ?? false) await _chatRoomsBox!.clear();
    if (_peersBox?.isOpen ?? false) await _peersBox!.clear();
    if (_userBox?.isOpen ?? false) await _userBox!.clear();
  }

  Future<void> panicWipe() async {
    debugPrint('Executing Panic Wipe...');
    // Delete physical files
    await Hive.deleteBoxFromDisk(AppConstants.messagesBox);
    await Hive.deleteBoxFromDisk(AppConstants.chatRoomsBox);
    await Hive.deleteBoxFromDisk(AppConstants.peersBox);
    await Hive.deleteBoxFromDisk(AppConstants.userBox);
  }
}
